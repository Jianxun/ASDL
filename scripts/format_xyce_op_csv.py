#!/usr/bin/env python3
"""Pivot Xyce operating-point device outputs to rows=device, cols=parameter.

Supports outputs generated by e.g.:
  .PRINT DC FORMAT=CSV N(*)

Input may be comma-separated (.csv) or whitespace-separated (.prn).
"""

from __future__ import annotations

import argparse
import csv
import re
import sys
from pathlib import Path

HEADER_RE = re.compile(r"^[A-Za-z]+\((.+)\)$")


def _read_xyce_table(path: Path) -> tuple[list[str], list[list[str]]]:
    lines = [line.strip() for line in path.read_text(encoding="utf-8").splitlines() if line.strip()]
    if not lines:
        raise ValueError(f"Input is empty: {path}")

    header_line = lines[0]
    is_csv = "," in header_line

    data_lines: list[str] = []
    for line in lines[1:]:
        if line.startswith("End of Xyce"):
            break
        data_lines.append(line)

    if not data_lines:
        raise ValueError(f"No data rows found in {path}")

    if is_csv:
        header = next(csv.reader([header_line]))
        rows = [next(csv.reader([line])) for line in data_lines]
    else:
        header = header_line.split()
        rows = [line.split() for line in data_lines]

    if any(len(row) != len(header) for row in rows):
        raise ValueError("Malformed table: row length does not match header length")

    return header, rows


def _extract_device_param(column_name: str) -> tuple[str, str] | None:
    match = HEADER_RE.match(column_name)
    if not match:
        return None

    inner = match.group(1)
    parts = inner.split(":")
    if len(parts) < 2:
        return None

    device = ":".join(parts[:-1])
    param = parts[-1]
    if not device or not param:
        return None
    return device, param


def pivot_xyce_operating_point(input_path: Path, row_index: int = 0) -> tuple[list[str], list[list[str]]]:
    header, rows = _read_xyce_table(input_path)

    if row_index < 0 or row_index >= len(rows):
        raise ValueError(f"row-index {row_index} is out of range for {len(rows)} row(s)")

    selected_row = rows[row_index]

    device_to_params: dict[str, dict[str, str]] = {}
    param_order: list[str] = []

    for col_name, value in zip(header, selected_row):
        parsed = _extract_device_param(col_name)
        if parsed is None:
            continue
        device, param = parsed
        if param not in param_order:
            param_order.append(param)
        device_to_params.setdefault(device, {})[param] = value

    if not device_to_params:
        raise ValueError(
            "No device parameter columns found. Expected headers like N(XDEV:...:PARAM)."
        )

    out_header = ["DEVICE", *param_order]
    out_rows: list[list[str]] = []
    for device in sorted(device_to_params):
        params = device_to_params[device]
        out_rows.append([device, *[params.get(param, "") for param in param_order]])

    return out_header, out_rows


def _write_csv(path: Path, header: list[str], rows: list[list[str]]) -> None:
    with path.open("w", encoding="utf-8", newline="") as handle:
        writer = csv.writer(handle)
        writer.writerow(header)
        writer.writerows(rows)


def parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Format Xyce DC operating-point output to rows=device, columns=parameter."
    )
    parser.add_argument("input", type=Path, help="Input Xyce table (.csv or .prn)")
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help="Output CSV path (default: <input>.pivot.csv)",
    )
    parser.add_argument(
        "--row-index",
        type=int,
        default=0,
        help="Data-row index to use when multiple rows are present (default: 0)",
    )
    return parser.parse_args(argv)


def main(argv: list[str]) -> int:
    args = parse_args(argv)

    output = args.output or args.input.with_suffix(args.input.suffix + ".pivot.csv")

    try:
        out_header, out_rows = pivot_xyce_operating_point(args.input, row_index=args.row_index)
        _write_csv(output, out_header, out_rows)
    except Exception as exc:  # noqa: BLE001
        print(f"error: {exc}", file=sys.stderr)
        return 1

    print(f"wrote {len(out_rows)} devices to {output}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
