# ASDL Design Decisions — Refactor Summary (Authoring-First, Agent-Native)

## 1. Core Framing
- **ASDL is an authoring IR**, not a simulator IR and not a GUI artifact.
- Schematic and netlist are **execution / UI substrates**, not suitable as native authoring substrates for AI agents.
- Agents must author, refactor, and reason over circuits **from scratch**, requiring:
  - declarative structure
  - explicit intent
  - stable semantics
  - low-cost iteration paths (open simulators)

---

## 2. Modules and Views (First-Class Semantics)

### 2.1 Views are mandatory (even if there is only one)
- Every `Module` conceptually has **one or more views**.
- Single-view modules are normalized to:
  ```yaml
  views:
    nominal: ...
  ```
- All downstream compiler logic operates on `views`, never on ad-hoc fields.

### 2.2 Canonical default view name
- **Canonical name**: `nominal`
- **Alias accepted**: `nom`
- Meaning:
  - Baseline intended structural implementation
  - Not corner-specific
  - Not extracted
  - Not idealized
- Explicitly **not** tied to:
  - schematic UI
  - TT/FF/SS corners
  - simulator choice

### 2.3 Reserved semantic view vocabulary
- Reserved view names (only): `nominal` (canonical; alias `nom` accepted) and `dummy`.
- All other view names are user-defined.
- Semantics:
  - `nominal` — baseline intended structural implementation (not corner-specific, not simulator-bound).
  - `dummy` — blackout / load-stub intent (for speed/stability).

---

## 3. Primitive vs Hierarchical — No Schema-Level Exclusivity

- Exclusivity between primitive and hierarchical implementations is **not inherent**.
- Real analog practice requires:
  - behavioral + transistor views
  - schematic + PEX views
  - dummy/blackbox substitutions
- **Decision**:
  - Authoring IR allows **multiple coexisting views**
  - Exclusivity is enforced only in a **lowered NetlistIR**, after view selection

---

## 4. View Kinds (Reserved Set)

Each view has an explicit `kind` drawn from the reserved set:

- `subckt` — hierarchical instances defined in ASDL (structural view).
- `primitive` — inline primitive rendering (spice_template-backed).
- `subckt_ref` — external netlist-backed implementation (PEX/vendor netlist) with explicit port→pin mapping.
- `dummy` — declarative spec for auto-generated blackout/placeholder circuits.

`pex` is **not** a separate kind; it is a specialization of `subckt_ref`.

---

## 5. PEX and External Netlists (First-Class)

### 5.1 Subckt-ref views
- PEX is a specialization of `subckt_ref`, not a separate kind.
- `subckt_ref` views:
  - reference an external netlist path
  - name the subckt
  - explicitly map ASDL ports → subckt pins
- Avoids duplicating PEX side-by-side with schematic design.

### 5.2 View selection determines whether PEX is used
- Same logical module
- Different implementation selected by config / view order

---

## 6. View Selection Semantics (Cadence-Compatible, Explicit)

### 6.1 Global view order
- ASDL supports Cadence-like netlisting view order:
  ```yaml
  view_order: ["pex", "nominal", "dummy"]
  ```

### 6.2 Config overrides (separate from design)
- View can be selected:
  - globally
  - per module
  - per instance (via hierarchical instance path)
- Config overlays are **not embedded** in circuit definition.

### 6.3 Selection always happens
- Even with one view, a `SelectViewPass` resolves `(module, view)` explicitly.
- This guarantees deterministic lowering and reproducibility.

---

## 7. Dummy / Blackout Views (Agent-Critical)

- Dummy views are **first-class**, not hacks.
- Common use cases:
  - speed up testbench simulation
  - black out large blocks
  - maintain DC stability
- Default strategy:
  - tie ports via very large resistors (gmin-like)
  - port-type–aware (signal vs power/ground)
- Dummy circuits are **auto-generated by a lowering pass**, not handwritten.

---

## 8. Corners and PVT — Explicitly Out of ASDL

- Circuit definitions are **corner-agnostic**.
- ASDL references:
  - logical model names only
- Corner selection is injected globally via:
  - model cards
  - simulator options
  - run configuration
- Views represent **modeling fidelity**, not PVT conditions.

---

## 9. Compiler Architecture (Refactor Spine)

### Authoring IR (ASDL)
- Modules + ports + parameters
- Views (multi-view, non-exclusive)
- No simulator / corner assumptions

### Key Passes
1. Parse & schema validation
2. Import & alias resolution
3. Pattern expansion
4. Elaboration (hierarchy, instance paths)
5. Apply config (view overrides, view order)
6. **SelectViewPass** (resolve view per instance)
7. Dummy / subckt lowering
8. Structural verification (ERC-like)
9. Backend lowering (ngspice / spectre)

### Lowered IR
- Exactly **one resolved implementation per module per build**
- Deterministic netlisting

---

## 10. Strategic Implications

- ASDL mirrors Cadence concepts (views, config, PEX) **explicitly**, not implicitly.
- Enables:
  - hybrid open + proprietary workflows
  - cheap agent iteration using open simulators
  - reduced Cadence license pressure
- Provides a canonical, semantic dataset representation for ML research.
- Positions ASDL as:
  > **the authoring substrate above all simulators and GUIs**

---

## Final Principle

> **ASDL encodes intent and structure.  
> Simulators execute.  
> Config selects context.  
> Views express fidelity.**

This separation is deliberate, foundational, and agent-native.
