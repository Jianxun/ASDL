# T-047: System Devices for Backend Structural Templates

**Status**: Ready
**Owner**: Executor
**Created**: 2026-01-03

---

## Objective

Refactor the ngspice emitter to use external backend configuration with system devices per ADR-0006. This decouples backend-specific syntax from emitter logic and enables extensibility for future backends (spectre, hspice, etc.).

---

## Background

### Current state (hardcoded ngspice syntax)

The emitter has three hardcoded ngspice syntax points:

1. **Subcircuit delimiters** (`_emit_module()` lines 114-119):
   ```python
   header = _format_subckt_line(module.sym_name.data, ports)
   footer = f".ends {module.sym_name.data}"
   if is_top and not options.top_as_subckt:
       header = f"*{header}"
       footer = f"*{footer}"
   ```

2. **Helper function** (`_format_subckt_line()` lines 397-400):
   ```python
   def _format_subckt_line(name: str, ports: List[str]) -> str:
       if ports:
           return f".subckt {name} {' '.join(ports)}"
       return f".subckt {name}"
   ```

3. **Module instantiation** (`_emit_instance()` lines 148-154):
   ```python
   if ref_name in modules:
       port_order = [attr.data for attr in modules[ref_name].port_order.data]
       conns, had_error = _ordered_conns(instance, port_order, diagnostics)
       if had_error:
           return None, True
       conn_str = " ".join(conns)
       return f"X{instance.name_attr.data} {conn_str} {ref_name}", False
   ```

### Desired state (template-driven)

All structural elements use backend-provided templates:
- `__subckt_header__` / `__subckt_footer__` for non-top modules
- `__top_header__` / `__top_footer__` for top modules
- `__subckt_call__` for module instantiation
- Optional `__netlist_header__` / `__netlist_footer__` for file-level preamble/postamble

---

## Implementation Plan

### Phase 1: Backend Config Infrastructure

#### 1.1 Create `src/asdl/emit/backend_config.py`

This module loads and validates backend configuration from YAML.

**Data structures:**
```python
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional
import os
import yaml

from asdl.diagnostics import Diagnostic, Severity

@dataclass(frozen=True)
class SystemDeviceTemplate:
    """A single system device template definition."""
    template: str

@dataclass(frozen=True)
class BackendConfig:
    """Backend configuration loaded from backends.yaml."""
    name: str
    system_devices: Dict[str, SystemDeviceTemplate]

# Required system devices (backends MUST define these)
REQUIRED_SYSTEM_DEVICES = {
    "__subckt_header__",
    "__subckt_footer__",
    "__top_header__",
    "__top_footer__",
    "__subckt_call__",
}

# Optional system devices (backends MAY define these)
OPTIONAL_SYSTEM_DEVICES = {
    "__netlist_header__",
    "__netlist_footer__",
}
```

**Functions to implement:**

1. `load_backend_config(backend_name: str, config_path: Optional[Path] = None) -> BackendConfig`
   - If `config_path` is None, use env var `ASDL_BACKEND_CONFIG` or default to `config/backends.yaml`
   - Load YAML file
   - Extract backend section by `backend_name`
   - Parse `system_devices` entries into `SystemDeviceTemplate` objects
   - Return `BackendConfig`
   - On error (file not found, missing backend, malformed YAML): raise appropriate exception

2. `validate_system_devices(config: BackendConfig) -> List[Diagnostic]`
   - Check that all required system devices are present
   - If missing, emit `MISSING_BACKEND` diagnostic with `Severity.ERROR`
   - Return list of diagnostics

**Error handling:**
- File not found: `FileNotFoundError` with clear message
- Backend not in file: Raise `KeyError` with message like `"Backend 'ngspice' not found in {config_path}"`
- Malformed YAML: Let `yaml.YAMLError` propagate (or wrap with clear message)

**Example YAML structure expected:**
```yaml
ngspice:
  system_devices:
    __subckt_header__:
      template: ".subckt {name} {ports}"
    __subckt_footer__:
      template: ".ends {name}"
    # ... etc
```

#### 1.2 Create `config/backends.yaml`

Move `examples/scratch/backends.yaml` to `config/backends.yaml` and populate with ngspice system devices:

```yaml
ngspice:
  system_devices:
    __subckt_header__:
      template: ".subckt {name} {ports}"
    __subckt_footer__:
      template: ".ends {name}"
    __top_header__:
      template: "*.subckt {name} {ports}"
    __top_footer__:
      template: "*.ends {name}"
    __subckt_call__:
      template: "X{name} {ports} {ref}"
    __netlist_header__:
      template: "* Generated by ASDL"
    __netlist_footer__:
      template: ".end"
```

**Note**: The `*` in `__top_header__` and `__top_footer__` templates comments out the line in ngspice syntax, matching current behavior.

#### 1.3 Update `EmitOptions` dataclass

Add `backend_config` field:

```python
@dataclass(frozen=True)
class EmitOptions:
    top_as_subckt: bool = False
    backend_name: str = "ngspice"
    backend_config: BackendConfig = None  # Add this field
```

---

### Phase 2: Emitter Refactoring

#### 2.1 Update `emit_ngspice()` function

Load backend config and validate system devices:

```python
def emit_ngspice(
    design: DesignOp,
    *,
    top_as_subckt: bool = False,
    backend_config_path: Optional[Path] = None,
) -> Tuple[Optional[str], List[Diagnostic]]:
    diagnostics: List[Diagnostic] = []

    # Load backend config
    try:
        config = load_backend_config("ngspice", backend_config_path)
    except (FileNotFoundError, KeyError, yaml.YAMLError) as exc:
        # Emit diagnostic for config loading failure
        diagnostics.append(
            _diagnostic(
                MISSING_BACKEND,
                f"Failed to load backend config: {exc}",
                Severity.ERROR,
            )
        )
        return None, diagnostics

    # Validate system devices
    validation_diags = validate_system_devices(config)
    diagnostics.extend(validation_diags)
    if any(d.severity == Severity.ERROR for d in validation_diags):
        return None, diagnostics

    options = EmitOptions(
        top_as_subckt=top_as_subckt,
        backend_config=config,
    )
    return _emit_design(design, options)
```

**Important**: Handle config loading errors gracefully. Don't let exceptions propagate - convert to diagnostics.

#### 2.2 Create `_render_system_device()` helper

This function is similar to `_emit_instance()` but for system devices:

```python
def _render_system_device(
    device_name: str,
    config: BackendConfig,
    context: Dict[str, str],
    diagnostics: List[Diagnostic],
) -> Tuple[Optional[str], bool]:
    """Render a system device template with the given context.

    Args:
        device_name: System device name (e.g., "__subckt_header__")
        config: Backend configuration containing system device templates
        context: Template placeholder values (e.g., {"name": "amp", "ports": "in out"})
        diagnostics: List to append any diagnostics

    Returns:
        (rendered_string, had_error) tuple
    """
    if device_name not in config.system_devices:
        diagnostics.append(
            _diagnostic(
                MISSING_BACKEND,
                f"System device '{device_name}' not defined in backend config",
                Severity.ERROR,
            )
        )
        return None, True

    sys_device = config.system_devices[device_name]
    template = sys_device.template

    # Validate template placeholders (reuse existing _validate_template logic if applicable)
    # For system devices, we don't enforce REQUIRED_PLACEHOLDERS - just validate syntax
    try:
        placeholders = _template_field_roots(template)
    except ValueError as exc:
        diagnostics.append(
            _diagnostic(
                MALFORMED_TEMPLATE,
                f"System device '{device_name}' template is malformed: {exc}",
                Severity.ERROR,
            )
        )
        return None, True

    # Render template
    try:
        rendered = template.format_map(context)
    except KeyError as exc:
        diagnostics.append(
            _diagnostic(
                UNKNOWN_REFERENCE,
                f"System device '{device_name}' template references unknown placeholder '{exc.args[0]}'",
                Severity.ERROR,
            )
        )
        return None, True
    except ValueError as exc:
        diagnostics.append(
            _diagnostic(
                MALFORMED_TEMPLATE,
                f"System device '{device_name}' template is malformed: {exc}",
                Severity.ERROR,
            )
        )
        return None, True

    # Whitespace collapsing: if {ports} is in placeholders and context["ports"] is empty, collapse whitespace
    should_collapse = False
    if "ports" in placeholders and context.get("ports", "") == "":
        should_collapse = True
    if should_collapse:
        rendered = " ".join(rendered.split())

    return rendered, False
```

**Key points:**
- Reuse `_template_field_roots()` for placeholder extraction
- Reuse diagnostic codes (`MALFORMED_TEMPLATE`, `UNKNOWN_REFERENCE`)
- Apply whitespace collapsing for empty `{ports}` (same as device instances)
- Don't enforce `REQUIRED_PLACEHOLDERS` - system devices have different requirements

#### 2.3 Refactor `_emit_module()`

Replace hardcoded header/footer logic with system device rendering:

**Before** (lines 113-119):
```python
ports = [attr.data for attr in module.port_order.data]
header = _format_subckt_line(module.sym_name.data, ports)
footer = f".ends {module.sym_name.data}"
if is_top and not options.top_as_subckt:
    header = f"*{header}"
    footer = f"*{footer}"
lines.append(header)
```

**After**:
```python
ports = [attr.data for attr in module.port_order.data]

# Select header/footer system devices based on is_top and top_as_subckt
if is_top and not options.top_as_subckt:
    header_device = "__top_header__"
    footer_device = "__top_footer__"
else:
    header_device = "__subckt_header__"
    footer_device = "__subckt_footer__"

# Render header
header_context = {"name": module.sym_name.data, "ports": " ".join(ports)}
header, header_error = _render_system_device(
    header_device,
    options.backend_config,
    header_context,
    diagnostics,
)
if header is not None:
    lines.append(header)
had_error = had_error or header_error

# ... emit instances ...

# Render footer
footer_context = {"name": module.sym_name.data}
footer, footer_error = _render_system_device(
    footer_device,
    options.backend_config,
    footer_context,
    diagnostics,
)
if footer is not None:
    lines.append(footer)
had_error = had_error or footer_error
```

**Remove**:
- Delete `_format_subckt_line()` function (lines 397-400)

#### 2.4 Refactor `_emit_instance()` for module instantiation

Replace hardcoded `X{name} {conns} {ref}` with `__subckt_call__` system device:

**Before** (lines 148-154):
```python
if ref_name in modules:
    port_order = [attr.data for attr in modules[ref_name].port_order.data]
    conns, had_error = _ordered_conns(instance, port_order, diagnostics)
    if had_error:
        return None, True
    conn_str = " ".join(conns)
    return f"X{instance.name_attr.data} {conn_str} {ref_name}", False
```

**After**:
```python
if ref_name in modules:
    port_order = [attr.data for attr in modules[ref_name].port_order.data]
    conns, had_error = _ordered_conns(instance, port_order, diagnostics)
    if had_error:
        return None, True

    # Use __subckt_call__ system device
    call_context = {
        "name": instance.name_attr.data,
        "ports": " ".join(conns),
        "ref": ref_name,
    }
    return _render_system_device(
        "__subckt_call__",
        options.backend_config,
        call_context,
        diagnostics,
    )
```

#### 2.5 Add optional netlist header/footer

In `_emit_design()`, add netlist header/footer rendering:

**After line 80** (before module loop):
```python
lines: List[str] = []

# Render netlist header if defined
if "__netlist_header__" in options.backend_config.system_devices:
    header_context = {"backend": options.backend_name, "top": top_name}
    header, _ = _render_system_device(
        "__netlist_header__",
        options.backend_config,
        header_context,
        diagnostics,
    )
    if header:
        lines.append(header)
```

**After line 94** (after module loop):
```python
# Render netlist footer if defined
if "__netlist_footer__" in options.backend_config.system_devices:
    footer_context = {"backend": options.backend_name, "top": top_name}
    footer, _ = _render_system_device(
        "__netlist_footer__",
        options.backend_config,
        footer_context,
        diagnostics,
    )
    if footer:
        lines.append(footer)
```

**Note**: These are optional - don't error if missing.

---

### Phase 3: Testing

#### 3.1 Create `tests/unit_tests/emit/test_backend_config.py`

Test backend config loading and validation:

```python
import pytest
from pathlib import Path
from asdl.emit.backend_config import (
    load_backend_config,
    validate_system_devices,
    BackendConfig,
    SystemDeviceTemplate,
    REQUIRED_SYSTEM_DEVICES,
)
from asdl.diagnostics import Severity

def test_load_valid_backend_config(tmp_path):
    """Test loading a valid backend config."""
    config_file = tmp_path / "backends.yaml"
    config_file.write_text("""
ngspice:
  system_devices:
    __subckt_header__:
      template: ".subckt {name} {ports}"
    __subckt_footer__:
      template: ".ends {name}"
    __top_header__:
      template: "*.subckt {name} {ports}"
    __top_footer__:
      template: "*.ends {name}"
    __subckt_call__:
      template: "X{name} {ports} {ref}"
""")

    config = load_backend_config("ngspice", config_file)
    assert config.name == "ngspice"
    assert len(config.system_devices) == 5
    assert config.system_devices["__subckt_header__"].template == ".subckt {name} {ports}"

def test_load_missing_backend(tmp_path):
    """Test loading a backend that doesn't exist in config."""
    config_file = tmp_path / "backends.yaml"
    config_file.write_text("ngspice:\n  system_devices: {}\n")

    with pytest.raises(KeyError, match="spectre"):
        load_backend_config("spectre", config_file)

def test_load_missing_file():
    """Test loading from a non-existent config file."""
    with pytest.raises(FileNotFoundError):
        load_backend_config("ngspice", Path("/nonexistent/backends.yaml"))

def test_validate_missing_required_devices():
    """Test validation fails when required system devices are missing."""
    config = BackendConfig(
        name="ngspice",
        system_devices={
            "__subckt_header__": SystemDeviceTemplate(template=".subckt {name}"),
            # Missing other required devices
        },
    )

    diags = validate_system_devices(config)
    assert len(diags) > 0
    assert any(d.severity == Severity.ERROR for d in diags)
    assert any("__subckt_footer__" in d.message for d in diags)

def test_validate_all_required_devices_present():
    """Test validation passes when all required devices are present."""
    config = BackendConfig(
        name="ngspice",
        system_devices={
            "__subckt_header__": SystemDeviceTemplate(template=".subckt {name}"),
            "__subckt_footer__": SystemDeviceTemplate(template=".ends {name}"),
            "__top_header__": SystemDeviceTemplate(template="*.subckt {name}"),
            "__top_footer__": SystemDeviceTemplate(template="*.ends {name}"),
            "__subckt_call__": SystemDeviceTemplate(template="X{name} {ports} {ref}"),
        },
    )

    diags = validate_system_devices(config)
    assert len(diags) == 0
```

**Coverage goals**:
- Valid config loading ✓
- Missing backend ✓
- Missing file ✓
- Missing required system devices ✓
- All required devices present ✓
- Malformed YAML (add test)

#### 3.2 Create `tests/unit_tests/netlist/test_system_devices.py`

Test system device rendering end-to-end:

```python
import pytest
from pathlib import Path
from asdl.emit.ngspice import emit_ngspice
from asdl.ir.ifir import DesignOp, ModuleOp
from asdl.diagnostics import Severity

# Use existing test fixtures or create minimal IFIR ops

def test_subckt_header_rendering(tmp_path):
    """Test that subckt header uses system device template."""
    # Create minimal DesignOp with one module
    # Call emit_ngspice with backend_config_path
    # Assert output contains ".subckt module_name port1 port2"

def test_top_header_commenting(tmp_path):
    """Test that top module header is commented when top_as_subckt=False."""
    # Create DesignOp with top module
    # Call emit_ngspice with top_as_subckt=False
    # Assert output contains "*.subckt module_name ..."

def test_top_header_not_commented(tmp_path):
    """Test that top module header is not commented when top_as_subckt=True."""
    # Create DesignOp with top module
    # Call emit_ngspice with top_as_subckt=True
    # Assert output contains ".subckt module_name ..." (no * prefix)

def test_subckt_call_rendering(tmp_path):
    """Test that module instantiation uses __subckt_call__ template."""
    # Create DesignOp with module instantiation
    # Assert output contains "X<instance_name> <conns> <module_ref>"

def test_netlist_header_footer(tmp_path):
    """Test that optional netlist header/footer are rendered."""
    # Create DesignOp
    # Assert output starts with "* Generated by ASDL"
    # Assert output ends with ".end"

def test_empty_ports_whitespace_collapse(tmp_path):
    """Test that empty ports trigger whitespace collapsing in templates."""
    # Create module with no ports
    # Assert output is ".subckt module_name" (not ".subckt module_name   ")
```

**Note**: Reuse existing IFIR test fixtures from `tests/unit_tests/netlist/test_emit.py` where possible.

#### 3.3 Regression testing

**Critical**: All existing netlist tests must pass with **byte-for-byte identical output**.

Run:
```bash
pytest tests/unit_tests/netlist/test_emit.py -v
```

If tests fail due to output differences:
1. Inspect the diff carefully
2. Ensure `config/backends.yaml` templates match previous hardcoded behavior exactly
3. Check whitespace handling (trailing spaces, empty ports, etc.)

**Example regression test strategy**:
- Before refactor: Capture output of `emit_ngspice()` for all test cases
- After refactor: Assert output matches captured baseline

---

### Phase 4: Documentation Updates

The spec has already been updated by the Architect. You should verify:

1. `docs/specs_mvp/spec_netlist_emission_mvp.md` includes system device documentation ✓
2. `agents/adr/ADR-0006-system-devices.md` exists ✓
3. Contract updated with system device invariants ✓

No additional doc updates needed.

---

## Files to Create

- `src/asdl/emit/backend_config.py` (new)
- `config/backends.yaml` (new, move from `examples/scratch/`)
- `tests/unit_tests/emit/test_backend_config.py` (new)
- `tests/unit_tests/netlist/test_system_devices.py` (new)

## Files to Modify

- `src/asdl/emit/ngspice.py`:
  - Update `emit_ngspice()` to load backend config
  - Update `EmitOptions` dataclass
  - Add `_render_system_device()` helper
  - Refactor `_emit_module()` to use system devices
  - Refactor `_emit_instance()` for module calls
  - Add netlist header/footer in `_emit_design()`
  - **Remove** `_format_subckt_line()` function

## Files to Update (tests)

- `tests/unit_tests/netlist/test_emit.py`: Update fixtures if needed (should pass unchanged)

---

## Constraints & Invariants

1. **No AST/IR changes**: System devices are emission-only; do not touch AST, NFIR, or IFIR
2. **Byte-for-byte output**: Existing examples must emit identically (regression test critical)
3. **Reserved names**: System device names prefixed `__` are reserved
4. **Required vs optional**: Missing required system devices = fatal; missing optional = OK
5. **Error handling**: All config loading errors → diagnostics, not exceptions
6. **Template placeholders**: Use same validation/rendering as device backends

---

## Verification Protocol

Before marking task complete:

1. ✅ `pytest tests/unit_tests/emit -v` (all pass)
2. ✅ `pytest tests/unit_tests/netlist -v` (all pass, identical output)
3. ✅ Manual smoke test: `asdlc netlist examples/scratch/test.asdl` (inspect output)
4. ✅ Code review checklist:
   - `_format_subckt_line()` removed
   - No hardcoded ngspice syntax remains in `ngspice.py`
   - `config/backends.yaml` exists with all required system devices
   - Backend config validation implemented
   - Diagnostics properly emitted for config errors

---

## Open Questions / Risks

1. **Environment variable**: Should we set `ASDL_BACKEND_CONFIG` in tests, or pass explicit path?
   - Recommendation: Pass explicit path in tests for isolation

2. **Default config path**: Should default be `config/backends.yaml` or detect project root?
   - Recommendation: Use relative path `config/backends.yaml` (assumes CWD is project root)

3. **Whitespace handling**: Does current emitter have edge cases with empty ports?
   - Recommendation: Test thoroughly with empty port lists

---

## Success Criteria

- [ ] Backend config loading works with env var and explicit path
- [ ] Validation catches missing required system devices
- [ ] Emitter uses system devices for headers, footers, module calls
- [ ] Hardcoded ngspice syntax removed from emitter
- [ ] All existing netlist tests pass with identical output
- [ ] New tests for backend config and system devices
- [ ] Code is clean, well-documented, and follows existing patterns

---

## Notes for Executor

- **Start with Phase 1**: Get backend config loading working before touching emitter
- **Incremental approach**: Implement and test each system device type separately
- **Regression testing is critical**: Run existing tests frequently during refactor
- **Reuse existing helpers**: `_template_field_roots()`, `_diagnostic()`, etc.
- **Watch for edge cases**: Empty ports, missing optional devices, malformed templates
- **Ask if stuck**: This is a significant refactor; Architect is available for clarification

Good luck! This refactor will significantly improve backend extensibility.
