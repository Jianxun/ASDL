# ────────────────────────────────────────────────────────────────────────────────
#  ASDL-YAML Schema (v0.4)  —  Analog Structural Description Language
#  Description for LLM reasoning — with expansion rules for differential and bus patterns
#  
#  🎉 LATEST REFINEMENTS (Phase 3 & 4 Enhancements):
#  • Enhanced Parameter Handling: New device_line + parameters approach
#  • Real PDK Integration: Support for complex device lines with expressions
#  • Field Consistency: Standardized 'doc' field naming
#  • Automatic Parameter Generation: Parameters auto-appended to device lines
#  • ngspice Validated: Perfect user workflow from xschem → ASDL → ngspice
# ────────────────────────────────────────────────────────────────────────────────

design_info:
  top_module: <module_id>              # Entry point module name for the circuit design
  doc: <string>                        # Human-readable description of the design file
  revision: <string>                   # Version tag (e.g. "v0.4")
  author: <string>                     # Author's name
  date: <YYYY-MM-DD>                   # Date in ISO 8601 format

models:
  <model_alias>:                       # Logical name used in the design (e.g. "nmos_unit")
    doc: <string>                      # Optional documentation for the device
    type: nmos|pmos|resistor|capacitor|diode|...
    ports: [<port1>, <port2>, ...]     # Ordered terminal list (for positional mapping)
    
    # NEW ROBUST APPROACH (Preferred):
    device_line: |                     # Raw PDK device line with {port} placeholders
      <PDK_device_line_template>       # Example: MN {D} {G} {S} {B} nfet_03v3 L=0.5u W=4u nf=2 ad='...'
    parameters:
      <param>: <default_value>         # Parameterizable values with defaults (e.g., M: 1)
    
    # LEGACY APPROACH (Backward compatibility):
    model: <string>                    # PDK-specific primitive model (e.g. "nch_lvt")
    params:
      <param>: <value>                 # Default parameters (e.g., W, L, C)
    description: <string>              # Legacy description field (for backward compatibility)

modules:
  <module_id>:
    doc: <string>                      # Description of module functionality

    ports:
      # One-line format (preferred for simple ports)
      <port_name>: {dir: in|out|in_out, type: voltage|current|digital, constraints: {common_mode: <value>, swing: {min: <ΔV>, max: <ΔV>}}}
      
      # Multi-line format (preferred for complex ports with many constraints)
      <port_name>:
        dir: in|out|in_out
        type: voltage|current|digital
        constraints:
          common_mode: <value>
          swing:
            min: <ΔV>
            max: <ΔV>
          # Additional constraints as needed

    nets:
      internal: [<net_name>, …]

    parameters:
      <param>: <value or expression>

    instances:
      <instance_id or pattern>:
        model: <model_alias or module_id>
        mappings: {<port>: <net>, ...}  # One-line format for simple mappings
        # OR
        mappings:                       # Multi-line format for expanded mappings
          <port_pattern>: <net_pattern>
        parameters:
          <param>: <value>
        intent:
          op:
            region: saturation|subthreshold|triode
            gm_over_Id: <value>        # Units: 1/V
            nominal_current: <value>   # Units: A
          layout:
            type: <string>             # Layout style (e.g., "quad_common_centroid")
            match_group: <string>      # Symmetry or matching tag
            symmetry: diff|quad|mirror|none

# ═══════════════════════════════════════════════════════════════
# ✨ ENHANCED PARAMETER HANDLING (NEW in v0.4) ✨
# ═══════════════════════════════════════════════════════════════

# The new robust approach enables seamless integration with real PDK device lines:
#
# 1. 🎯 PERFECT USER WORKFLOW:
#    • User creates device in xschem schematic
#    • User netlists the schematic
#    • User copies device line EXACTLY to ASDL YAML device_line field
#    • ASDL preserves expressions exactly as-is
#    • ngspice simulates perfectly with ZERO manual intervention
#
# 2. 🔧 AUTOMATIC PARAMETER GENERATION:
#    • Parameters declared in 'parameters' section are automatically appended
#    • Format: device_line + " M={M} nf={nf}" (auto-generated)
#    • No manual parameter formatting required = No errors
#
# 3. 🧠 EXPRESSION PRESERVATION:
#    • Complex expressions like "ad='int((nf+1)/2) * W/nf * 0.18u'" preserved exactly
#    • ngspice automatically resolves expressions using hard-coded parameter values
#    • No parameter extraction or expression flattening needed
#
# 4. 🏗️ CLEAN SEPARATION:
#    • device_line: Core PDK device definition
#    • parameters: Parameterizable values with defaults
#    • Auto-combined during SPICE generation

# ───────────────────────────────────────────
# FORMAT PREFERENCES & EXAMPLES
# ───────────────────────────────────────────

# 1. Port Definitions
#    a. One-line format (preferred for simple ports):
#       ports:
#         in_<p,n>:  {dir: in,  type: voltage, constraints: {common_mode: 0.6}}
#         out:       {dir: out, type: voltage}
#         vdd:       {dir: in_out, type: voltage, constraints: {Vdd: 1.8}}
#
#    b. Multi-line format (preferred for complex ports):
#       ports:
#         in_<p,n>:
#           dir: in
#           type: voltage
#           constraints:
#             common_mode: 0.6
#             swing:
#               min: 0.3
#               max: 0.9

# 2. Simple Mappings (One-line format)
#    mappings: {G: vbn, D: tail, S: vss, B: vss}
#    mappings: {plus: in, minus: out}

# 3. Expanded Mappings (Multi-line format)
#    mappings:
#      G:  in_<p,n>             # CORRECT: model port maps to expanded nets
#      D:  out_<p,n>            # CORRECT: model port maps to expanded nets
#      S:  tail                 # Broadcast to all instances

# 4. Enhanced Model Definition (NEW APPROACH)
#    device_line: |
#      MN {D} {G} {S} {B} nfet_03v3 L=0.5u W=4u nf=2 ad='int((nf+1)/2) * W/nf * 0.18u'
#    parameters:
#      M: 1
#    # Automatically generates: MN D G S B nfet_03v3 L=0.5u W=4u nf=2 ad='...' M={M}
#
# 5. Terminal Naming
#    - Use plus/minus for capacitor/resistor terminals
#    - Use G/D/S/B for transistor terminals

# ───────────────────────────────────────────
# NAMING & EXPANSION RULES — MUST BE FOLLOWED
# ───────────────────────────────────────────

# 1. Angle Brackets <...>: Differential or symbolic pattern expansion
#    Syntax: name_<a,b> expands into two identifiers: name_a, name_b
#    Use cases: ports, nets, instance names, or keys/values in mappings
#
#    Example:
#      in_<p,n> → in_p, in_n
#      MN_<P,N> → MN_P, MN_N
#
#    Used to declare symmetric structures (e.g., differential pairs)

# 2. Square Brackets [...]: Bus or array expansion
#    Syntax: name[3:0] expands into: name[3], name[2], name[1], name[0]
#    Use cases: ports, nets, or instances representing vector signals or arrays

# 3. Expansion in `mappings` is **order matched, not value matched**
#    That is, positional index i in the expanded key maps to the i-th element in the expanded value,
#    even if suffixes differ.
#
#    Example (polarity inversion):
#      mappings:
#        D_<p,n>: out_<n,p>
#
#    Expands to:
#        D_p: out_n
#        D_n: out_p
#
#    Likewise:
#      mappings:
#        G:  in_<p,n>               # CORRECT: G connects to in_p, in_n for each instance
#        S:  tail                   # Broadcast: both instances connect S to tail
#
#    Values can be scalars or single-entry patterns, in which case they are broadcast to all expanded keys.

# 4. Symbol substitution:
#    Any `$param_name` expression is replaced by the value of the corresponding module parameter.

# 5. Expansion symmetry is **semantic** and optional:
#    You may declare:
#      expansion_type: diff
#    or
#      layout.symmetry: quad
#    as optional metadata to assist LLMs or rendering/layout tools in understanding structure.

# ──────────────────────────────────────────────────────────────
# COMPLETE EXAMPLES - Latest Refinements (Enhanced Parameter Handling)
# ──────────────────────────────────────────────────────────────

# ═══════════════════════════════════════════════════════════════
# EXAMPLE 1: Basic CMOS Inverter (Real PDK Integration)
# ═══════════════════════════════════════════════════════════════

design_info:
  top_module: inverter
  doc: "Basic CMOS inverter with enhanced parameter handling"
  revision: "v0.4"
  author: "ASDL"
  date: "2024-03-19"

models:
  # ─── NEW ROBUST APPROACH: Real PDK Device Lines ───
  nmos_unit:
    doc: "NMOS transistor unit cell"
    type: nmos
    ports: [G, D, S, B]
    device_line: |
      MN {D} {G} {S} {B} nfet_03v3 L=0.5u W=4u nf=2 ad='int((nf+1)/2) * W/nf * 0.18u' as='int((nf+2)/2) * W/nf * 0.18u' pd='2*int((nf+1)/2) * (W/nf + 0.18u)' ps='2*int((nf+2)/2) * (W/nf + 0.18u)' nrd='0.18u / W' nrs='0.18u / W' sa=0 sb=0 sd=0
    parameters:
      M: 1

  pmos_unit:
    doc: "PMOS transistor unit cell"
    type: pmos
    ports: [G, D, S, B]
    device_line: |
      MP {D} {G} {S} {B} pfet_03v3 L=0.5u W=5u nf=2 ad='int((nf+1)/2) * W/nf * 0.18u' as='int((nf+2)/2) * W/nf * 0.18u' pd='2*int((nf+1)/2) * (W/nf + 0.18u)' ps='2*int((nf+2)/2) * (W/nf + 0.18u)' nrd='0.18u / W' nrs='0.18u / W' sa=0 sb=0 sd=0
    parameters:
      M: 1

modules:
  inverter:
    doc: "Basic CMOS inverter with PMOS pull-up and NMOS pull-down"
    ports:
      in:  {dir: in,  type: voltage}
      out: {dir: out, type: voltage}
      vss: {dir: in_out, type: voltage}
      vdd: {dir: in_out, type: voltage, constraints: {Vdd: 1.8}}
    parameters:
      M: 1
    instances:
      MP:
        model: pmos_unit
        mappings: {G: in, D: out, S: vdd, B: vdd}
        parameters:
          M: 2
        intent:
          op:
            region: saturation
            gm_over_Id: 10
          layout:
            type: single
            symmetry: none
      MN:
        model: nmos_unit
        mappings: {G: in, D: out, S: vss, B: vss}
        parameters:
          M: 2
        intent:
          op:
            region: saturation
            gm_over_Id: 10
          layout:
            type: single
            symmetry: none

# ═══════════════════════════════════════════════════════════════
# EXAMPLE 2: Differential Pair with Pattern Expansion
# ═══════════════════════════════════════════════════════════════

# diff_pair_nmos:
#   ports:
#     in_<p,n>:  {dir: in,  type: voltage}
#     out_<p,n>: {dir: out, type: voltage}
#     tail:      {dir: in_out, type: voltage}
#     vss:       {dir: in_out, type: voltage}
#   instances:
#     MN_<P,N>:
#       model: nmos_unit
#       mappings:
#         G:  in_<p,n>             # Correct: model port name (no pattern) maps to expanded nets
#         D:  out_<n,p>            # Order-matched → polarity swap
#         S:  tail                 # Broadcast to all instances
#         B:  vss                  # Broadcast to all instances
