ASDL Test Suite Development & Maintenance Rules

Scope
- Applies to tests under `tests/` (unit and integration) for parser, elaborator, validator, and generator.
- Goal: Fast, deterministic, code-specific tests with clear diagnostics and minimal flakiness.

1) Structure & Taxonomy
- Unit tests live in `tests/unit_tests/{component}/` with focused scope:
  - `parser/`, `elaborator/`, `validator/`, `generator/`
- Integration tests live in `tests/integration/` and exercise pipeline flows.
- Parser positive-path tests are grouped (not per-code):
  - `test_parser_basics.py`, `test_parser_modules.py`, `test_parser_location_tracking.py`, `test_parser_positive_paths.py`.

2) Naming & Granularity
- Prefer one-code-one-test files for diagnostics (XCCSS):
  - Example: `tests/unit_tests/parser/test_p0240_missing_port_dir.py`
  - Example: `tests/unit_tests/parser/test_p0511_invalid_port_direction_enum.py`
- Keep negative tests per diagnostic; centralize shared positive-path assertions in a few focused files.
- Avoid mega-tests; split by single responsibility (structure vs semantics vs env behavior).

3) Diagnostic Assertions (XCCSS-first)
- Always assert on diagnostic codes, not only titles/messages.
- Prefer specific codes over generic fallbacks:
  - Enums: use P0511/P0512 (not generic P0205) where applicable.
  - Unknowns: P0701 (top-level), P0702 (field-level).
  - Required fields: P0240 (port dir), P0250 (instance model).
  - Parser YAML syntax/root: P0101/P0102.
- Optional INFO diagnostics:
  - P0103 (Empty File) is opt-in via `ASDLParser(emit_empty_file_info=True)`; do not break legacy tests that expect no diagnostics for empty content.
- Parser vs Elaborator scope:
  - Parser handles structure/type checks; do NOT test global duplicate detection here.
  - Cross-file/alias/module existence belongs in Elaborator (E044x).

4) Environment Hygiene
- Do not use `sys.path` hacks in tests.
  - Rely on `pyproject.toml` `[tool.pytest.ini_options].pythonpath = [".", "src"]`.
- Use the project venv (`venv/`) when running tests locally.
- Avoid external I/O; prefer `tempfile.TemporaryDirectory()` for file-based tests.

5) Determinism & Isolation
- No reliance on test order; tests must be order-independent.
- No global mutable state across tests.
- Use minimal YAML strings in parser tests; prefer in-memory over filesystem unless path resolution is under test.
- For filesystem tests, fully control the directory under `tempfile` and assert only on created artifacts.

6) Assertions & Severity
- For components that may emit warnings (e.g., Elaborator quality diagnostics):
  - Assert that no ERROR diagnostics are present, rather than `len(diagnostics) == 0`.
- For parser unit tests with expected positive paths: allow zero diagnostics unless the case explicitly tests warnings.

7) Location & Metadata
- When testing location tracking, assert presence and correctness of `file_path`, `start_line`, `start_col` where meaningful.
- Do not over-assert on columns for multi-line YAML unless necessary (avoid brittleness).

8) Helpers & Fixtures
- Prefer constructing YAML via inline triple-quoted strings for readability.
- Use well-named local helpers inside a test file if repeated; avoid central megafixtures.
- Reuse `tempfile.TemporaryDirectory()` for file and import resolution scenarios.

9) TDD Workflow (per change)
- Write a failing test first (narrow scope, code-specific).
- Run only the relevant subset (`pytest tests/unit_tests/parser -q`).
- Implement the minimum change to pass; re-run.
- Refactor while keeping tests green.
- Update docs (`doc/parser/parser_error_codes.md`) and docstrings for new/changed diagnostics.

10) Performance & Stability
- Keep unit tests fast (<100ms typical per file); avoid sleeps/timeouts.
- Use parametrization for small matrix checks instead of copy-paste.
- Mark expensive scenarios as integration tests.

11) Documentation Alignment
- Any introduced/modified diagnostic code must be reflected in:
  - `src/asdl/parser/diagnostics.py` registry (if parser code).
  - `doc/parser/parser_error_codes.md` (status, examples, severity).
  - Related module docstrings updated to reflect XCCSS terminology.

12) Examples
- Parser enum validation (prefer specific codes):
```python
yaml_content = """
file_info:
  top_module: "m"
modules:
  m:
    ports:
      a: {dir: input, type: voltage}
    spice_template: "R {a} {a} 1k"
"""
parser = ASDLParser()
asdl_file, diagnostics = parser.parse_string(yaml_content)
assert any(d.code == "P0511" for d in diagnostics)
```

- Optional P0103 (empty file):
```python
parser = ASDLParser(emit_empty_file_info=True)
asdl_file, diagnostics = parser.parse_string("")
assert asdl_file is None
assert any(d.code == "P0103" for d in diagnostics)
```

13) CI Expectations
- Tests must pass without network, rely only on repo files and temp dirs.
- No environment mutations (e.g., os.environ) leaked across tests.
- Keep consistent with `pyproject.toml` configuration; no per-file path tweaks.

14) When Updating Legacy Tests
- Replace legacy P104/P105/P200/P201 expectations with XCCSS equivalents.
- Remove `sys.path` manipulation and rely on project pythonpath.
- Convert generic parse errors to specific enum/field codes where behavior supports it.

Checklist (PR Ready)
- [ ] One-test-per-code added/updated where diagnostics changed
- [ ] Positive-path tests still green
- [ ] No `sys.path` hacks
- [ ] Docs updated (error codes, docstrings)
- [ ] Scoped `pytest` run for the modified component is green

